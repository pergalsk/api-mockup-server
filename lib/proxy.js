/**
 * Proxy module. Handle proxy http requests.
 * @module proxy
 */
const querystring = require('querystring');
const { createProxyMiddleware, responseInterceptor } = require('http-proxy-middleware');
const { match } = require('path-to-regexp');

const { getState } = require('./store');
const { isFn, getPathname } = require('./utils');
const { MOCK_HEADER_NAME } = require('./constants');
const defaultOptions = require('./definitions');
const routing = require('./register');
const log = require('./log');
const _t = require('./texts');

/**
 * Method generates HTTP Proxy Middleware.
 * @param {Object} serverOptions API Mockup Server options
 * @returns {Promise<Function>} ExpressJS HTTP Proxy Middleware
 */
function getProxy(serverOptions) {
  const { prefix, routes, proxy } = serverOptions;
  const { target, suspended, isRestart } = getState();

  if (!target || target === -1) {
    !isRestart && log.serverMsg(_t('PROXY_NOT_CONFIGURED'));
    return (req, res, next) => {
      next();
    };
  }

  const contexts = suspended == null || suspended === 'TURNING_OFF' ? getPaths(prefix, routes) : [];
  const onProxyReq = getOnProxyReqFn();
  const onProxyRes = getOnProxyResFn(contexts, serverOptions);
  const options = { target, onProxyReq, onProxyRes };

  const proxyMiddleware = createProxyMiddleware(getFilterFn(contexts), {
    ...defaultOptions.proxy,
    ...options,
  });

  if (!Array.isArray(proxy.server) || proxy.server.length <= 1) {
    !isRestart && log.proxyTarget(target);
  }

  if (suspended == null && !isRestart) {
    log.serverMsg(_t('PROXY_CONFIGURED'));
  }

  return proxyMiddleware;
}

/**
 * Generates `onProxyReq` method needed for intercept proxy requests.
 *
 * Why we use onProxyReq method is if there is parsed body in request we need to re-stream
 * it before proxying. It causes problem with PUT/POST proxied responses.
 * Inspired by:
 * https://github.com/chimurai/http-proxy-middleware/issues/320#issuecomment-474922392
 * https://github.com/chimurai/http-proxy-middleware/issues/40#issuecomment-249430255
 *
 * @returns {Function} HPM `onProxyReq` method
 */
function getOnProxyReqFn() {
  return (proxyReq, req, res, options) => {
    if (!proxyReq || !req || !req.body || !Object.keys(req.body).length) {
      return;
    }

    const writeBody = (bodyData) => {
      proxyReq.setHeader('Content-Length', Buffer.byteLength(bodyData));
      proxyReq.write(bodyData); // stream the content
    };

    const contentType = proxyReq.getHeader('Content-Type');

    if (contentType.includes('application/json')) {
      writeBody(JSON.stringify(req.body));
    }

    if (contentType === 'application/x-www-form-urlencoded') {
      // TODO: Nodejs querystring is deprecated
      writeBody(querystring.stringify(req.body));
    }
  };
}

/**
 * Generates `onProxyRes` method needed for intercept proxy responses.
 * @param {Array<Object>} contexts Contexts - active routes containing method for matching tested path
 * @param {Object} serverOptions API Mockup Server options
 * @returns {Function} `onProxyRes` function generated by HPM `responseInterceptor` method
 */
function getOnProxyResFn(contexts, serverOptions) {
  return responseInterceptor(async (responseBuffer, proxyRes, req, res) => {
    const { encoding, mockHeader } = serverOptions;

    // TODO: make header value more detailed (proxy,static,dynamic,file,inline,delay)
    let mockHeaderValue = 'proxy';

    const contentType = proxyRes.headers['content-type'];
    if (!contentType || !contentType.includes('application/json')) {
      mockHeader && res.setHeader(MOCK_HEADER_NAME, mockHeaderValue);
      return responseBuffer;
    }

    const context = contexts.find(getMatchRouteFn(req, req.originalUrl));
    if (!context || !isFn(context.callback)) {
      mockHeader && res.setHeader(MOCK_HEADER_NAME, mockHeaderValue);
      return responseBuffer;
    }

    try {
      let parsedData = JSON.parse(responseBuffer.toString(encoding));

      const { key, callback } = context;
      const { params, query, body } = req;
      const callbackProps = { params, query, body, data: parsedData, req };

      try {
        parsedData = await callback(callbackProps);
        // parsedData = global.structuredClone(callbackData);
        mockHeaderValue += ',intercept';
      } catch (error) {
        log.fnErrorStart(key || '-', 'callback');
        console.error(error);
        log.fnErrorEnd(key || '-', 'callback');
      }
      mockHeader && res.setHeader(MOCK_HEADER_NAME, mockHeaderValue);
      const responseData = JSON.stringify(parsedData);
      log.callbackProxy(req.method, proxyRes.statusCode, key, req.originalUrl);

      return responseData;
    } catch (e) {
      log.error(_t('ERROR_IN_PROCESSING_JSON_DATA'));
      return responseBuffer;
    }
  });
}

/**
 * HPM filter method with shortened notation due to minimize HPM logging.
 * (pathname, req) => m(pathname, req, contexts)
 * @param {Array<Object>} c Contexts - active routes containing method for matching tested path
 * @returns {Function} HPM filter function
 */
function getFilterFn(c) {
  return (p, r) => m(p, r, c);
}

/**
 * HPM filter method for matching routes.
 * @param {string} pathname Tested pathname
 * @param {Object} req ExpressJS request
 * @param {Array<Object>} contexts Contexts - active routes containing method for matching tested path
 * @returns {boolean} `true` if path should be proxied
 */
function m(pathname, req, contexts) {
  const skipInterceptors = true;
  return !contexts.some(getMatchRouteFn(req, pathname, skipInterceptors));
}

/**
 * Generates iteratee method - the function invoked per context iteration.
 * It checks if request matches tested context.
 * @param {Object} req ExpressJS request
 * @param {string} pathname Tested pathname
 * @param {boolean} skipInterceptors If `true` proxy interceptors are skipped in matching
 * @returns {(Object) => boolean} Iteratee method
 */
function getMatchRouteFn(req, pathname, skipInterceptors = false) {
  return (context) => {
    // match request method
    const methodMatch = context.method === req.method;
    if (!methodMatch) {
      return false;
    }

    // match path using generated regexp
    const pathMatch = context.match(getPathname(pathname));
    if (!pathMatch) {
      return false;
    }

    if (skipInterceptors) {
      // check if context is proxy interceptor
      const proxyInterceptor = routing.isProxyInterceptor(context, getState().target);
      if (proxyInterceptor) {
        return false;
      }
    }

    if (context._applyIfResult === false) {
      delete context._applyIfResult; // clear for next route call
      return false; // previously evaluated as false
    }

    // check if it should be applied using applyIf method
    const shouldApply = shouldApplyCheck(req, context, pathMatch, skipInterceptors);
    if (!shouldApply) {
      context._applyIfResult = false; // clear for next route call
      return false;
    }

    // all checks passed
    return true;
  };
}

/**
 * Get active paths prepared for route matching.
 * @param {string} prefix Route prefix
 * @param {Array<Object>} routes Routes defined in API Mockup Server options
 * @returns {Array<Object>} Contexts - active routes containing method for matching tested path
 */
function getPaths(prefix, routes) {
  const { method } = defaultOptions.route;
  return routing.getActiveRoutes(routes).map((route) => ({
    key: route.key,
    path: route.path,
    method: route.method || method,
    applyIf: route.applyIf,
    callback: route.callback,
    data: route.data,
    match: match(((route.prefix ?? prefix) || '') + route.path, { decode: decodeURIComponent }),
  }));
}

/**
 * Determines whether a condition specified by `context.applyIf` is met for a given request.
 * @param {Object} req - The HTTP request object, containing `query` and `body` properties.
 * @param {Object} context - The context object, which may contain an `applyIf` function.
 * @param {Object} pathMatch - An object containing route matching parameters, including `params`.
 * @returns {boolean} - Returns true if the condition is met otherwise, false.
 */
function shouldApplyCheck(req, context, pathMatch, skipInterceptors) {
  const { query, body } = req;
  const { applyIf, key } = context;
  const { params } = pathMatch;

  if (!isFn(applyIf)) {
    return true; // route definition should be applied
  }

  try {
    return Boolean(applyIf({ params, query, body, req }));
  } catch (error) {
    log.fnErrorStart(key || '-', 'applyIf');
    console.error(error);
    log.fnErrorEnd(key || '-', 'applyIf');
    return false; // there is an error -> do not apply
  }
}

module.exports = {
  getPaths,
  getProxy,
};
