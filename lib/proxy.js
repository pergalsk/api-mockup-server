/**
 * Proxy module. Handle proxy http requests.
 * @module proxy
 */
const querystring = require('querystring');
const { createProxyMiddleware, responseInterceptor } = require('http-proxy-middleware');
const { match } = require('path-to-regexp');
const inquirer = require('inquirer');

const { isFn, getPathname } = require('./utils');
const { MOCK_HEADER_NAME } = require('./constants');
const defaultOptions = require('./definitions');
const routing = require('./register');
const log = require('./log');
const _t = require('./texts');

/**
 * Method generates HTTP Proxy Middleware.
 * @param {Object} serverOptions API Mockup Server options
 * @param {string|number|null} target Proxy target URL
 * @returns {Promise<Function>} ExpressJS HTTP Proxy Middleware
 */
function getProxy(serverOptions, target) {
  const { prefix, routes, proxy, encoding } = serverOptions;

  if (!target || target === -1) {
    log.serverMsg(_t('PROXY_NOT_CONFIGURED'));
    return (req, res, next) => {
      next();
    };
  }

  const contexts = getPaths(prefix, routes);
  const onProxyReq = getOnProxyReqFn();
  const onProxyRes = getOnProxyResFn(contexts, serverOptions, target);
  const options = { target, onProxyReq, onProxyRes };

  const proxyMiddleware = createProxyMiddleware(getFilterFn(contexts, target), {
    ...defaultOptions.proxy,
    ...options,
  });

  if (!Array.isArray(proxy.server) || proxy.server.length <= 1) {
    log.proxyTarget(target);
  }
  log.serverMsg(_t('PROXY_CONFIGURED'));

  return proxyMiddleware;
}

/**
 * Generates `onProxyReq` method needed for intercept proxy requests.
 *
 * Why we use onProxyReq method is if there is parsed body in request we need to re-stream
 * it before proxying. It causes problem with PUT/POST proxied responses.
 * Inspired by:
 * https://github.com/chimurai/http-proxy-middleware/issues/320#issuecomment-474922392
 * https://github.com/chimurai/http-proxy-middleware/issues/40#issuecomment-249430255
 *
 * @returns {Function} HPM `onProxyReq` method
 */
function getOnProxyReqFn() {
  return (proxyReq, req, res, options) => {
    if (!proxyReq || !req || !req.body || !Object.keys(req.body).length) {
      return;
    }

    const writeBody = (bodyData) => {
      proxyReq.setHeader('Content-Length', Buffer.byteLength(bodyData));
      proxyReq.write(bodyData); // stream the content
    };

    const contentType = proxyReq.getHeader('Content-Type');

    if (contentType.includes('application/json')) {
      writeBody(JSON.stringify(req.body));
    }

    if (contentType === 'application/x-www-form-urlencoded') {
      // TODO: Nodejs querystring is deprecated
      writeBody(querystring.stringify(req.body));
    }
  };
}

/**
 * Generates `onProxyRes` method needed for intercept proxy responses.
 * @param {Array<Object>} contexts Contexts - active routes containing method for matching tested path
 * @param {Object} serverOptions API Mockup Server options
 * @returns {Function} `onProxyRes` function generated by HPM `responseInterceptor` method
 */
function getOnProxyResFn(contexts, serverOptions) {
  return responseInterceptor(async (responseBuffer, proxyRes, req, res) => {
    const { encoding, mockHeader } = serverOptions;

    // TODO: make header value more detailed (proxy,static,dynamic,file,inline,delay)
    let mockHeaderValue = 'proxy';

    const contentType = proxyRes.headers['content-type'];
    if (!contentType || !contentType.includes('application/json')) {
      mockHeader && res.setHeader(MOCK_HEADER_NAME, mockHeaderValue);
      return responseBuffer;
    }

    const context = contexts.find(getMatchRouteFn(req, req.originalUrl));
    if (!context || !isFn(context.callback)) {
      mockHeader && res.setHeader(MOCK_HEADER_NAME, mockHeaderValue);
      return responseBuffer;
    }

    try {
      let parsedData = JSON.parse(responseBuffer.toString(encoding));

      const { key, callback } = context;
      const { params, query, body } = req;
      const callbackProps = { params, query, body, data: parsedData, req };

      try {
        const callbackData = await callback(callbackProps);
        parsedData = global.structuredClone(callbackData);
        mockHeaderValue += ',intercept';
      } catch (error) {
        log.fnErrorStart(key || '-', 'callback');
        console.error(error);
        log.fnErrorEnd(key || '-', 'callback');
      }
      mockHeader && res.setHeader(MOCK_HEADER_NAME, mockHeaderValue);
      const responseData = JSON.stringify(parsedData);
      log.callbackProxy(req.method, proxyRes.statusCode, key, req.originalUrl);

      return responseData;
    } catch (e) {
      log.error(_t('ERROR_IN_PROCESSING_JSON_DATA'));
      return responseBuffer;
    }
  });
}

/**
 * HPM filter method with shortened notation due to minimize HPM logging.
 * (pathname, req) => m(pathname, req, contexts)
 * @param {Array<Object>} c Contexts - active routes containing method for matching tested path
 * @param {string|number|null} t Proxy target (proxy server URL)
 * @returns {Function} HPM filter function
 */
function getFilterFn(c, t) {
  return (p, r) => m(p, r, c, t);
}

/**
 * HPM filter method for matching routes.
 * @param {string} pathname Tested pathname
 * @param {Object} req ExpressJS request
 * @param {Array<Object>} contexts Contexts - active routes containing method for matching tested path
 * @param {string|number|null} target Proxy target (proxy server URL)
 * @returns {boolean} `true` if path should be proxied
 */
function m(pathname, req, contexts, target) {
  const skipInterceptors = true;
  return !contexts.some(getMatchRouteFn(req, pathname, target, skipInterceptors));
}

/**
 * Generates iteratee method - the function invoked per context iteration.
 * It checks if request matches tested context.
 * @param {Object} req ExpressJS request
 * @param {string} pathname Tested pathname
 * @param {string|number|null} target Proxy target (proxy server URL)
 * @param {boolean} skipInterceptors If `true` proxy interceptors are skipped in matching
 * @returns {(Object) => boolean} Iteratee method
 */
function getMatchRouteFn(req, pathname, target, skipInterceptors = false) {
  return (context) => {
    // match request method
    const methodMatch = context.method === req.method;
    if (!methodMatch) {
      return false;
    }

    // match path using generated regexp
    const pathMatch = context.match(getPathname(pathname));
    if (!pathMatch) {
      return false;
    }

    if (skipInterceptors) {
      const proxyInterceptor = routing.isProxyInterceptor(context, target);
      if (proxyInterceptor) {
        return false;
      }
    }
    // check if context is proxy interceptor

    // check if it should be applied using applyIf method
    const shouldApply = shouldApplyCheck(req, context, pathMatch);
    if (!shouldApply) {
      return false;
    }

    // all checks passed
    return true;
  };
}

/**
 * Get active paths prepared for route matching.
 * @param {string} prefix Route prefix
 * @param {Array<Object>} routes Routes defined in API Mockup Server options
 * @returns {Array<Object>} Contexts - active routes containing method for matching tested path
 */
function getPaths(prefix, routes) {
  const { method } = defaultOptions.route;
  return routing.getActiveRoutes(routes).map((route) => ({
    key: route.key,
    path: route.path,
    method: route.method || method,
    applyIf: route.applyIf,
    callback: route.callback,
    data: route.data,
    match: match(((route.prefix ?? prefix) || '') + route.path, { decode: decodeURIComponent }),
  }));
}

/**
 * Determines whether a condition specified by `context.applyIf` is met for a given request.
 * @param {Object} req - The HTTP request object, containing `query` and `body` properties.
 * @param {Object} context - The context object, which may contain an `applyIf` function.
 * @param {Object} pathMatch - An object containing route matching parameters, including `params`.
 * @returns {boolean} - Returns true if the condition is met otherwise, false.
 */
function shouldApplyCheck(req, context, pathMatch) {
  const { query, body } = req;
  const { applyIf, key } = context;
  const { params } = pathMatch;

  // This method is invoked 2x per request. Result/error can be used
  // from previous call in the same route.
  let { applyIfResult, applyIfError } = context;

  if (!isFn(applyIf)) {
    return true; // route definition should be applied
  }

  if (applyIfError === true) {
    delete context.applyIfError; // clear for next route call
    return false; // there is an error -> do not apply
  }

  if (applyIfResult !== undefined) {
    delete context.applyIfResult; // clear for next route call
    return applyIfResult;
  }

  try {
    context.applyIfResult = !!applyIf({ params, query, body, req });
    return context.applyIfResult; // apply if result is truthy
  } catch (error) {
    context.applyIfError = true;
    log.fnErrorStart(key || '-', 'applyIf');
    console.error(error);
    log.fnErrorEnd(key || '-', 'applyIf');
    return false; // there is an error -> do not apply
  }
}

/**
 * Method fetches proxy target from server options.
 * If there is multiple targets, when the server starts it runs CLI
 * for getting choice from user.
 * @async
 * @param {string|Array<string>} proxy API Mockup Server proxy options
 * @returns {string} proxy target (proxy server URL)
 */
async function getProxyTarget(proxy) {
  if (!proxy || !proxy.server) {
    return null;
  }

  if (typeof proxy.server === 'string') {
    return proxy.server;
  }

  if (!Array.isArray(proxy.server)) {
    return null;
  }

  if (proxy.server.length === 0) {
    return null;
  }

  if (proxy.server.length === 1) {
    return proxy.server[0];
  }

  const choices = [
    {
      name: _t('WITHOUT_PROXY'),
      value: null,
    },
    ...proxy.server.map((item) => ({
      name: item,
      value: item,
    })),
    // todo: exit choice
    // {
    //   name: _t('EXIT'),
    //   value: -1,
    // },
  ];

  // get value from interactive CLI
  const prompt = await inquirer.prompt([{ ...defaultOptions.prompt.proxy, choices }]);

  return prompt.target;
}

module.exports = {
  getPaths,
  getProxy,
  getProxyTarget,
};
